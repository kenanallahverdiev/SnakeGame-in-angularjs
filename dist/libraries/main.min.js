var app=angular.module('app', ['ngRoute']);

app.config(['$routeProvider', function ($routeProvider) {
    $routeProvider
        .when('/game', {
            templateUrl: 'snake.html',
            controller: 'GameController'
        })
        .otherwise({redirectTo: '/game'});
}]);
app.controller('GameController',function($scope,$timeout, $window,$selfPlay,$snake,$forage){

    const directions={
        left:39,
        right:37,
        up:38,
        down:40
    };
    const boardSize=25;
    
    var speed;
    var timer;

    $scope.score = 0;

    $scope.checkPost = function(){
        $selfPlay.SaveTrainData();
    }

    $scope.init = function(){
        $snake.init();
        $forage.init();

        $scope.score=0;
        speed=200;
        if(timer!=null){
            $timeout.cancel(timer);
        }

        generateForage();
    };

    $scope.over = function(){
        $timeout.cancel(timer);
        $selfPlay.SaveTrainData();
        alert("Game Over Your Score is "+$scope.score);
    };

    
    $scope.startGame=function(){
        $scope.init();
        Move();
    };

    function Move(){
        let headNode = $snake.getNewHeadNode();

        if($snake.isInBody(headNode)){
            $scope.over();
            return;
        }

        if(isInWallBody(headNode)){
            $scope.over();
            return;
        }

        $snake.addNewHead(headNode);
        
        if($forage.isInBody(headNode)){
            eatForage();
        }

        $snake.removeBeginNode();

        $snake.snake.Direction =  $snake.snake.NextDirection;
   
        timer = $timeout(Move,speed);
    }

    function isInWallBody(location) {
        return location.X < 0 || location.Y < 0 || location.X >= boardSize || location.Y >= boardSize;
    };

    function eatForage(){
        $snake.addNewNode();
        if(speed>20){
            speed-=10;
        }
        $scope.score+=10;
        generateForage();
    };

    function generateForage(){
        $forage.init();

        if($snake.isInBody($forage.forage)){
            generateForage();
        }
    };

    //ui control
    $scope.getforageX = function(){
        return $forage.getXpx();
    }; 
    $scope.getforageY =function(){
        return $forage.getYpx();
    }; 
    
    $scope.getXmove = function(index){
        return $snake.getXpx(index);
    } 
    $scope.getYmove = function(index){
        return $snake.getYpx(index);
    } 

    $scope.getSnakLength = function(){
        return new Array($snake.NodeSize);
    };

    $window.addEventListener("keydown", function (e) 
    {
        var keyCode = e.keyCode;
        if (keyCode === directions.left && $snake.snake.Direction !== directions.right) {
            $snake.snake.NextDirection = directions.left;
        } else if (keyCode === directions.right && $snake.snake.Direction !== directions.left) {
            $snake.snake.NextDirection = directions.right;
        } else if (keyCode === directions.up && $snake.snake.Direction !== directions.down) {
            $snake.snake.NextDirection = directions.up;
        } else if (keyCode === directions.down && $snake.snake.Direction !== directions.up) {
            $snake.snake.NextDirection = directions.down;
        } else {
            
        }
    });


    //self playing
    function setSelfPlayingObject(){
        $selfPlay.setSnake($snake.snake.Nodes[$snake.NodeSize-1],$snake.snake.Direction);
        $selfPlay.setForage($forage.forage);
    }

    $scope.startSelfPlaying = function(){
        if(timer!=null){
            $timeout.cancel(timer);
        }
        $scope.score = 0;
        speed = 200;
        $scope.init();
        generateForage();
        selfPlaying();
        Move();
    };

    function selfPlaying()
    {
        setSelfPlayingObject();
        var keyCode = $selfPlay.generateDirection();
        if (keyCode === directions.left && $snake.snake.Direction !== directions.right) {
            $snake.snake.NextDirection = directions.left;
        } else if (keyCode === directions.right && $snake.snake.Direction !== directions.left) {
            $snake.snake.NextDirection = directions.right;
        } else if (keyCode === directions.up && $snake.snake.Direction !== directions.down) {
            $snake.snake.NextDirection = directions.up;
        } else if (keyCode === directions.down && $snake.snake.Direction !== directions.up) {
            $snake.snake.NextDirection = directions.down;
        } else {
            
        }
        $timeout(selfPlaying,10);
    };


    $scope.init();
});
app.factory('$forage',function(){

    var service = {
        forage:{
            X:Math.floor(Math.random()*boardSize),
            Y:Math.floor(Math.random()*boardSize)
        },
    };

    var boardSize = 25;
   
    service.init = function (){
        service.forage={
            X:Math.floor(Math.random()*boardSize),
            Y:Math.floor(Math.random()*boardSize)
        };
    };


    service.isInBody = function (location){
        return location.X == service.forage.X && location.Y == service.forage.Y;
    };

    service.getXpx = function (){
        return service.forage.X*20 +'px'
    };

    service.getYpx = function (){
        return service.forage.Y*20 +'px'
    };

    return service;
});
app.factory('$selfPlay',function($http){
    
    var service = {
        
    };
    var directions = {
        left:39,
        right:37,
        up:38,
        down:40
    };

    var prevDirection = directions.left;

    var trainingData = {
        data:[]
    };



    service.setSnake = function(snake,direction){
        service.snake = {
            X:snake.X,
            Y:snake.Y,
            Direction:direction
        };
    }

    service.setForage = function(forage){
        service.forage = forage;
    }

    service.generateDirection = function (){
         let direction = calculateDirection();
         return direction;
    }

    function calculateDirection(){
        let movementDirection = {
            X: service.forage.X - service.snake.X,
            Y: service.forage.Y - service.snake.Y,
        };

        let direction = getDirectionStatus(movementDirection);
        
        if(direction != prevDirection){
            console.log(movementDirection);
            console.log('Direction:'+direction);
            prevDirection = direction;
        }

        let trainObj = {
            input: {snakeX:service.snake.X, snakeY:service.snake.Y, forageX:service.forage.X, forageY:service.forage.Y, snakeDirection:service.snake.Direction},
            output: {}
        };

        let directionName='left';
        if(direction == 37){
            directionName = 'right';
        }
        else if(directions == 38){
            directionName = 'up';
        }
        else if(directions == 40){
            directionName = 'down';
        }

        trainObj.output[directionName] = direction;
        
        trainingData.data.push(trainObj);
        return direction;
    }

    function getDirectionStatus(movementDirection)
    {
        if(movementDirection.X < 0){
            return directions.right;
        }
        else if(movementDirection.X > 0){
            return directions.left;
        }
        else if(movementDirection.X == 0 && (service.snake.Direction == directions.up || service.snake.Direction == directions.down)){
            return prevDirection;
        }
        else if(movementDirection.Y < 0){
            return directions.up;
        }
        else if(movementDirection.Y > 0){
            return directions.down;
        }
        else if(movementDirection.Y == 0 && (service.snake.Direction == directions.right || service.snake.Direction == directions.left)){
            return prevDirection;
        }
    }

    service.SaveTrainData = function(){
        var json = JSON.stringify(trainingData);
        
        console.log(json)
    };

    return service;
});
app.factory('$snake',function(){

    var service = {
        snake:null,
        NodeSize:0,
    };

    const directions={
        left:39,
        right:37,
        up:38,
        down:40
    };

    service.init = function (){
        service.snake = {
            Nodes:[{X:0,Y:0},{X:1,Y:0},{X:2,Y:0}],
            Direction:directions.left,
            NextDirection:directions.left
        };
        service.NodeSize = 3;
    };

    service.isInBody = function (location){
        for(let index=0;index < service.NodeSize;index++){
            if(service.snake.Nodes[index].X===location.X && service.snake.Nodes[index].Y===location.Y){
                return true;
            }
        }
        return false;
    };

    service.addNewNode = function (){
        var node = angular.copy(service.snake.Nodes[service.NodeSize-1]);
        service.snake.Nodes.push(node);
        service.NodeSize ++ ;
    };

    service.removeBeginNode = function(){
        service.snake.Nodes.shift();
        service.NodeSize -- ;
    };

    service.addNewHead = function (Head){
        service.snake.Nodes.push(Head);
        service.NodeSize ++ ;
    };

    service.getNewHeadNode = function(){
        let node = angular.copy(service.snake.Nodes[service.NodeSize-1]);
       
        if(service.snake.NextDirection===directions.left){
            node.X++;
        }
        else if(service.snake.NextDirection===directions.right){
            node.X--;
        }
        else if(service.snake.NextDirection===directions.up){
            node.Y--;
        }
        else if(service.snake.NextDirection===directions.down){
            node.Y++;
        }
        return node;
    };

    service.getXpx = function (index){
        return service.snake.Nodes[index].X*20 +'px'
    };

    service.getYpx = function (index){
        return service.snake.Nodes[index].Y*20 +'px'
    };


    return service;
});